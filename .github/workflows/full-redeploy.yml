name: Full Redeploy Bot (Complete Codebase Copy)

on:
  workflow_dispatch:
    inputs:
      reason:
        description: 'Reason for full redeployment'
        required: false
        default: 'Manual full redeploy triggered'

permissions:
  contents: write
  issues: write
  pull-requests: write
  actions: read
  checks: read

jobs:
  # Phase 1: Infrastructure Preparation
  infrastructure-setup:
    runs-on: ubuntu-latest
    outputs:
      vm_ip: ${{ steps.vm_info.outputs.vm_ip }}
      ssh_status: ${{ steps.ssh_test.outputs.status }}
    steps:
      - name: Checkout Code
        uses: actions/checkout@v4
      
      - name: Authenticate with GCP
        uses: google-github-actions/auth@v2
        with:
          credentials_json: ${{ secrets.GCP_CREDENTIALS }}
      
      - name: Get VM Information
        id: vm_info
        run: |
          echo "üîó Testing GCloud SSH connection to arccorp-compute..."
          if gcloud compute ssh arccorp-compute --zone=us-central1-a --project=rl-prod-471116 --command="echo 'GCloud SSH connection test successful'" --ssh-flag="-o ConnectTimeout=30"; then
            echo "‚úÖ GCloud SSH connection successful"
          else
            echo "‚ö†Ô∏è GCloud SSH test failed - continuing anyway"
          fi
          
          # Get current VM IP for Ansible
          echo "üîç Getting current VM IP address..."
          VM_IP=$(gcloud compute instances describe arccorp-compute --zone=us-central1-a --project=rl-prod-471116 --format="get(networkInterfaces[0].accessConfigs[0].natIP)" || echo "")
          if [ -z "$VM_IP" ]; then
            echo "‚ùå Could not get VM IP address, using fallback"
            VM_IP="34.30.73.146"
          fi
          echo "üìç Current VM IP: $VM_IP"
          echo "vm_ip=$VM_IP" >> $GITHUB_OUTPUT
      
      - name: Setup SSH Access
        id: ssh_test
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.BOT_SSH_PRIVATE_KEY }}" > ~/.ssh/id_rsa
          chmod 600 ~/.ssh/id_rsa
          # Add host key for the current IP
          ssh-keyscan -H ${{ steps.vm_info.outputs.vm_ip }} >> ~/.ssh/known_hosts || true
          echo "üîç Testing SSH connection for Ansible to ${{ steps.vm_info.outputs.vm_ip }}..."
          if ssh -o StrictHostKeyChecking=no -o ConnectTimeout=30 ubuntu@${{ steps.vm_info.outputs.vm_ip }} "echo 'Ansible SSH connection test successful'"; then
            echo "status=success" >> $GITHUB_OUTPUT
            echo "‚úÖ SSH connection successful"
          else
            echo "status=failed" >> $GITHUB_OUTPUT
            echo "‚ö†Ô∏è SSH test failed - will continue anyway"
          fi
      
      - name: Create Ansible Inventory
        run: |
          # Create a temporary inventory file with the current IP
          mkdir -p /tmp/ansible
          cat > /tmp/ansible/inventory.ini << EOF
          [arccorp_compute]
          ${{ steps.vm_info.outputs.vm_ip }} ansible_user=ubuntu ansible_ssh_private_key_file=~/.ssh/id_rsa

          [arccorp_compute:vars]
          ansible_python_interpreter=/usr/bin/python3
          EOF
          echo "üìã Dynamic inventory file created:"
          cat /tmp/ansible/inventory.ini
      
      - name: Upload Ansible Inventory
        uses: actions/upload-artifact@v4
        with:
          name: ansible-inventory
          path: /tmp/ansible/inventory.ini
          retention-days: 1

  # Phase 2: Full Codebase Deployment
  full-codebase-deployment:
    runs-on: ubuntu-latest
    needs: infrastructure-setup
    outputs:
      deployment_status: ${{ steps.deploy.outputs.status }}
    steps:
      - name: Checkout Code
        uses: actions/checkout@v4
      
      - name: Download Ansible Inventory
        uses: actions/download-artifact@v4
        with:
          name: ansible-inventory
          path: /tmp/ansible/
      
      - name: Setup SSH Key
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.BOT_SSH_PRIVATE_KEY }}" > ~/.ssh/id_rsa
          chmod 600 ~/.ssh/id_rsa
          ssh-keyscan -H ${{ needs.infrastructure-setup.outputs.vm_ip }} >> ~/.ssh/known_hosts || true
      
      - name: Setup Python and Ansible
        uses: actions/setup-python@v4
        with:
          python-version: '3.9'
      
      - name: Install Ansible
        run: |
          python -m pip install --upgrade pip
          pip install ansible
      
      - name: Authenticate with GCP
        uses: google-github-actions/auth@v2
        with:
          credentials_json: ${{ secrets.GCP_CREDENTIALS }}
      
      - name: Run Full Codebase Deployment
        id: deploy
        run: |
          echo "=== Starting Full Codebase Deployment ==="
          echo "üîÑ Reason: ${{ github.event.inputs.reason }}"
          echo "üìÖ Initiated at: $(date)"
          
          # Run Ansible playbook with full copy deployment
          if ansible-playbook ansible/full-deploy.yml -i /tmp/ansible/inventory.ini -v; then
            echo "status=success" >> $GITHUB_OUTPUT
            echo "‚úÖ Full codebase deployment completed successfully"
          else
            echo "status=failed" >> $GITHUB_OUTPUT
            echo "‚ùå Full codebase deployment failed"
            exit 1
          fi
          
          echo "=== Waiting for bot to stabilize after full deployment ==="
          sleep 15
          echo "=== Bot startup wait completed ==="
        env:
          DISCORD_TOKEN: ${{ secrets.DISCORD_TOKEN }}
          TEXT_CHANNEL_ID: ${{ secrets.TEXT_CHANNEL_ID }}
          DATABASE_URL: ${{ secrets.DATABASE_URL }}

  # Phase 3: Enhanced Health Verification
  health-verification:
    runs-on: ubuntu-latest
    needs: [infrastructure-setup, full-codebase-deployment]
    outputs:
      health_status: ${{ steps.health_check.outputs.status }}
      process_status: ${{ steps.health_check.outputs.process_status }}
      command_count: ${{ steps.health_check.outputs.command_count }}
    steps:
      - name: Setup SSH Access
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.BOT_SSH_PRIVATE_KEY }}" > ~/.ssh/id_rsa
          chmod 600 ~/.ssh/id_rsa
          ssh-keyscan -H ${{ needs.infrastructure-setup.outputs.vm_ip }} >> ~/.ssh/known_hosts || true
      
      - name: Enhanced Discord Bot Health Check
        id: health_check
        run: |
          echo "=== Enhanced Discord Bot Health Check ==="
          
          # Function to check if bot responds to Discord
          check_discord_health() {
            local max_attempts=5
            local attempt=1
            
            while [ $attempt -le $max_attempts ]; do
              echo "Health check attempt $attempt/$max_attempts..."
              
              # Send a test message to Discord and check if bot processes it
              # Using a simple API call to check if bot is online
              HEALTH_CHECK=$(curl -s -X GET \
                "https://discord.com/api/v10/applications/@me" \
                -H "Authorization: Bot ${{ secrets.DISCORD_TOKEN }}" \
                -H "Content-Type: application/json")
              
              if echo "$HEALTH_CHECK" | grep -q '"id"'; then
                echo "‚úÖ Bot is authenticated and responding to Discord API"
                
                # Additional check: verify bot can access guild information
                GUILD_CHECK=$(curl -s -X GET \
                  "https://discord.com/api/v10/users/@me/guilds" \
                  -H "Authorization: Bot ${{ secrets.DISCORD_TOKEN }}" \
                  -H "Content-Type: application/json")
                
                if echo "$GUILD_CHECK" | grep -q '\[.*\]'; then
                  echo "‚úÖ Bot can access guild information"
                  
                  # Check if bot has slash commands registered
                  COMMANDS_CHECK=$(curl -s -X GET \
                    "https://discord.com/api/v10/applications/@me/commands" \
                    -H "Authorization: Bot ${{ secrets.DISCORD_TOKEN }}" \
                    -H "Content-Type: application/json")
                  
                  COMMAND_COUNT=$(echo "$COMMANDS_CHECK" | grep -o '"name"' | wc -l)
                  echo "command_count=$COMMAND_COUNT" >> $GITHUB_OUTPUT
                  echo "‚úÖ Bot has $COMMAND_COUNT slash commands registered"
                  
                  echo "‚úÖ Enhanced Discord health check PASSED"
                  return 0
                else
                  echo "‚ö†Ô∏è Bot authenticated but cannot access guilds"
                fi
              else
                echo "‚ùå Bot not responding to Discord API"
              fi
              
              echo "Waiting 15 seconds before retry..."
              sleep 15
              attempt=$((attempt + 1))
            done
            
            echo "‚ùå Enhanced Discord health check FAILED after $max_attempts attempts"
            return 1
          }
          
          # Check process status via SSH
          echo "=== Process Status Check ==="
          PROCESS_STATUS=$(ssh -o StrictHostKeyChecking=no ubuntu@${{ needs.infrastructure-setup.outputs.vm_ip }} '
            if [ -f "/app/bot.pid" ]; then
              PID=$(cat /app/bot.pid)
              if ps -p "$PID" > /dev/null 2>&1; then
                echo "running"
              else
                echo "stopped"
              fi
            else
              echo "no_pid"
            fi
          ' || echo "ssh_failed")
          
          echo "process_status=$PROCESS_STATUS" >> $GITHUB_OUTPUT
          echo "Process status: $PROCESS_STATUS"
          
          # Primary health check: Discord API response
          if check_discord_health; then
            echo "status=success" >> $GITHUB_OUTPUT
            echo "‚úÖ Enhanced health verification PASSED"
          else
            echo "status=failed" >> $GITHUB_OUTPUT
            echo "‚ùå Enhanced health verification FAILED"
            exit 1
          fi

  # Phase 4: Full Deployment Log Collection
  log-collection:
    runs-on: ubuntu-latest
    needs: [infrastructure-setup, full-codebase-deployment, health-verification]
    if: always()
    steps:
      - name: Authenticate with GCP
        uses: google-github-actions/auth@v2
        with:
          credentials_json: ${{ secrets.GCP_CREDENTIALS }}
      
      - name: Collect Full Deployment Logs
        run: |
          echo "=== Full Deployment Log Collection ==="
          
          # Create a comprehensive log collection script
          cat > /tmp/full_deployment_check.sh << 'EOF'
          #!/bin/bash
          echo "=== Full Deployment Status Report ==="
          echo "Deployment Type: Complete Codebase Copy"
          echo "Timestamp: $(date)"
          echo "Reason: ${{ github.event.inputs.reason }}"
          
          # Check if this is a first deployment
          if [ ! -d /app ]; then
            echo "‚ÑπÔ∏è  First deployment in progress - /app directory does not exist yet"
            echo "This is normal during initial setup"
            echo "=== System resource check ==="
            free -h || echo "Could not check memory"
            echo "=== Full deployment log capture completed ==="
            exit 0
          fi
          
          # Show detailed bot status
          echo "=== Bot Process Status ==="
          if [ -f /app/bot.pid ]; then
            PID=$(cat /app/bot.pid)
            if ps -p "$PID" > /dev/null 2>&1; then
              echo "‚úÖ Bot is running (PID: $PID)"
              echo "Process details:"
              ps aux | grep "$PID" | grep -v grep || echo "Could not get process details"
            else
              echo "‚ö†Ô∏è Bot PID file exists but process not found (PID: $PID)"
              # Check if there is another python process running
              if pgrep -f "python.*main.py" > /dev/null; then
                ACTUAL_PID=$(pgrep -f "python.*main.py")
                echo "üîç Found bot process running with different PID: $ACTUAL_PID"
                echo "This may indicate a PID file sync issue"
              else
                echo "‚ùå No bot process found"
              fi
            fi
          else
            echo "‚ùå No bot PID file found"
          fi
          
          # Show file structure
          echo "=== Deployed File Structure ==="
          if [ -d /app ]; then
            echo "Top-level files:"
            ls -la /app/ | head -20
            echo ""
            echo "Source directory:"
            ls -la /app/src/ 2>/dev/null | head -10 || echo "No src directory found"
          fi
          
          # Show recent logs (more lines for full deployment)
          echo "=== Last 50 lines of bot log ==="
          if [ -f /app/bot.log ]; then
            tail -50 /app/bot.log
          else
            echo "‚ùå No bot log file found"
            echo "Checking for alternative log locations..."
            find /app -name "*.log" -type f 2>/dev/null | head -5 | while read logfile; do
              echo "Found log: $logfile"
              tail -10 "$logfile"
            done
          fi
          
          # Check system resources
          echo "=== System resource check ==="
          if [ -d /app ]; then
            df -h /app || echo "Could not check disk space for /app"
          else
            df -h / || echo "Could not check disk space"
          fi
          free -h || echo "Could not check memory"
          
          # Check Python environment
          echo "=== Python Environment ==="
          which python3 || echo "Python3 not found in PATH"
          python3 --version || echo "Could not get Python version"
          python3 -m pip list | grep -E "(discord|psycopg2|requests)" || echo "Could not check key packages"
          
          echo "=== Full deployment log capture completed ==="
          EOF
          
          # Copy script to VM and execute
          gcloud compute scp /tmp/full_deployment_check.sh arccorp-compute:/tmp/ --zone=us-central1-a --project=rl-prod-471116 || echo "Could not copy script to VM"
          gcloud compute ssh arccorp-compute --zone=us-central1-a --project=rl-prod-471116 --command="chmod +x /tmp/full_deployment_check.sh && /tmp/full_deployment_check.sh" || echo "Could not capture full deployment logs - VM may be unreachable"

  # Phase 5: Post Full Deployment Actions
  post-deployment:
    runs-on: ubuntu-latest
    needs: [infrastructure-setup, full-codebase-deployment, health-verification, log-collection]
    if: always()
    steps:
      - name: Full Deployment Success Notification
        if: needs.infrastructure-setup.result == 'success' && needs.full-codebase-deployment.result == 'success' && needs.health-verification.result == 'success'
        run: |
          echo "üéâ Full Deployment Successful!"
          echo "=== Deployment Summary ==="
          echo "Type: Complete Codebase Copy"
          echo "Reason: ${{ github.event.inputs.reason }}"
          echo "VM IP: ${{ needs.infrastructure-setup.outputs.vm_ip }}"
          echo "Process Status: ${{ needs.health-verification.outputs.process_status }}"
          echo "Slash Commands: ${{ needs.health-verification.outputs.command_count }}"
          echo "=== Next Steps ==="
          echo "1. Test slash commands in Discord by typing /red"
          echo "2. Verify all bot functionality is working"
          echo "3. Monitor bot logs for any issues"
          echo ""
          echo "‚úÖ Full codebase has been completely redeployed!"
      
      - name: Full Deployment Failure Notification
        if: always() && !(needs.infrastructure-setup.result == 'success' && needs.full-codebase-deployment.result == 'success' && needs.health-verification.result == 'success')
        run: |
          echo "‚ùå Full Deployment Failed!"
          echo "=== Failure Summary ==="
          echo "Type: Complete Codebase Copy"
          echo "Reason: ${{ github.event.inputs.reason }}"
          echo "Infrastructure Setup: ${{ needs.infrastructure-setup.result }}"
          echo "Full Deployment: ${{ needs.full-codebase-deployment.result }}"
          echo "Health Check: ${{ needs.health-verification.result }}"
          echo ""
          echo "‚ö†Ô∏è Review the logs above for detailed error information"
          echo "üí° Consider using the regular deploy workflow for incremental changes"