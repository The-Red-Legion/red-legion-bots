name: Deploy Bot

on:
  pull_request:
    branches: [main]
    types: [labeled]

permissions:
  contents: write
  issues: write
  pull-requests: write
  actions: read
  checks: read

jobs:
  deploy-arccorp-compute:
    runs-on: ubuntu-latest
    if: contains(github.event.pull_request.labels.*.name, 'deploy') && contains(github.event.pull_request.labels.*.name, 'tests good')
    steps:
      - uses: actions/checkout@v4
      - uses: google-github-actions/auth@v2
        with:
          credentials_json: ${{ secrets.GCP_CREDENTIALS }}
      - name: Test GCloud SSH connection and get current IP
        id: vm_info
        run: |
          echo "üîó Testing GCloud SSH connection to arccorp-compute..."
          if gcloud compute ssh arccorp-compute --zone=us-central1-a --project=rl-prod-471116 --command="echo 'GCloud SSH connection test successful'" --ssh-flag="-o ConnectTimeout=30"; then
            echo "‚úÖ GCloud SSH connection successful"
          else
            echo "‚ö†Ô∏è GCloud SSH test failed - continuing anyway"
          fi
          
          # Get current VM IP for Ansible
          echo "üîç Getting current VM IP address..."
          VM_IP=$(gcloud compute instances describe arccorp-compute --zone=us-central1-a --project=rl-prod-471116 --format="get(networkInterfaces[0].accessConfigs[0].natIP)" || echo "")
          if [ -z "$VM_IP" ]; then
            echo "‚ùå Could not get VM IP address, using fallback"
            VM_IP="34.30.73.146"
          fi
          echo "üìç Current VM IP: $VM_IP"
          echo "vm_ip=$VM_IP" >> $GITHUB_OUTPUT
      - name: Set up SSH key for Ansible
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.BOT_SSH_PRIVATE_KEY }}" > ~/.ssh/id_rsa
          chmod 600 ~/.ssh/id_rsa
          # Add host key for the current IP
          ssh-keyscan -H ${{ steps.vm_info.outputs.vm_ip }} >> ~/.ssh/known_hosts || true
          echo "üîç Testing SSH connection for Ansible to ${{ steps.vm_info.outputs.vm_ip }}..."
          ssh -o StrictHostKeyChecking=no -o ConnectTimeout=30 ubuntu@${{ steps.vm_info.outputs.vm_ip }} "echo 'Ansible SSH connection test successful'" || echo "SSH test failed - continuing anyway"
      - name: Create dynamic inventory for Ansible
        run: |
          # Create a temporary inventory file with the current IP
          mkdir -p /tmp/ansible
          cat > /tmp/ansible/inventory.ini << EOF
          [arccorp_compute]
          ${{ steps.vm_info.outputs.vm_ip }} ansible_user=ubuntu ansible_ssh_private_key_file=~/.ssh/id_rsa

          [arccorp_compute:vars]
          ansible_python_interpreter=/usr/bin/python3
          EOF
          echo "üìã Dynamic inventory file created:"
          cat /tmp/ansible/inventory.ini
      - name: Setup Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.9'
      - uses: google-github-actions/auth@v2
        with:
          credentials_json: ${{ secrets.GCP_CREDENTIALS }}
      - name: Install Ansible
        run: |
          python -m pip install --upgrade pip
          pip install ansible

      - name: Deploy to Compute Instance with Ansible
        run: |
          echo "=== Starting Ansible deployment ==="

          # Run Ansible playbook with dynamic inventory using environment variables
          ansible-playbook ansible/deploy.yml -i /tmp/ansible/inventory.ini -v

          echo "=== Ansible deployment completed ==="
          
          echo "=== Waiting for bot to stabilize ==="
          sleep 10
          echo "=== Bot startup wait completed ==="
        env:
          DISCORD_TOKEN: ${{ secrets.DISCORD_TOKEN }}
          TEXT_CHANNEL_ID: ${{ secrets.TEXT_CHANNEL_ID }}
          DATABASE_URL: ${{ secrets.DATABASE_URL }}
        shell: bash
      - name: Verify Bot Health
        run: |
          echo "=== Discord Bot Health Check ==="
          
          # Function to check if bot responds to Discord
          check_discord_health() {
            local max_attempts=3
            local attempt=1
            
            while [ $attempt -le $max_attempts ]; do
              echo "Health check attempt $attempt/$max_attempts..."
              
              # Send a test message to Discord and check if bot processes it
              # Using a simple API call to check if bot is online
              HEALTH_CHECK=$(curl -s -X GET \
                "https://discord.com/api/v10/applications/@me" \
                -H "Authorization: Bot ${{ secrets.DISCORD_TOKEN }}" \
                -H "Content-Type: application/json")
              
              if echo "$HEALTH_CHECK" | grep -q '"id"'; then
                echo "‚úÖ Bot is authenticated and responding to Discord API"
                
                # Additional check: verify bot can access guild information
                GUILD_CHECK=$(curl -s -X GET \
                  "https://discord.com/api/v10/users/@me/guilds" \
                  -H "Authorization: Bot ${{ secrets.DISCORD_TOKEN }}" \
                  -H "Content-Type: application/json")
                
                if echo "$GUILD_CHECK" | grep -q '\[.*\]'; then
                  echo "‚úÖ Bot can access guild information"
                  echo "‚úÖ Discord health check PASSED"
                  return 0
                else
                  echo "‚ö†Ô∏è Bot authenticated but cannot access guilds"
                fi
              else
                echo "‚ùå Bot not responding to Discord API"
              fi
              
              echo "Waiting 10 seconds before retry..."
              sleep 10
              attempt=$((attempt + 1))
            done
            
            echo "‚ùå Discord health check FAILED after $max_attempts attempts"
            return 1
          }
          
          # Also check if process exists (supplementary check)
          echo "=== Process Status Check ==="
          if [ -f "/app/bot.pid" ]; then
            PID=$(cat /app/bot.pid)
            echo "Found PID file with PID: $PID"
            
            if ps -p "$PID" > /dev/null 2>&1; then
              echo "‚úÖ Bot process is running (PID: $PID)"
              PROCESS_STATUS="running"
            else
              echo "‚ö†Ô∏è Bot process not found, but this may be a false negative"
              PROCESS_STATUS="unknown"
            fi
          else
            echo "‚ö†Ô∏è No PID file found at /app/bot.pid"
            PROCESS_STATUS="no_pid"
          fi
          
          # Check recent bot logs for activity
          echo "=== Bot Log Analysis ==="
          if [ -f "/app/bot.log" ]; then
            echo "Recent bot log entries:"
            tail -10 /app/bot.log
            
            # Check for recent heartbeat messages
            if grep -q "Heartbeat: Bot is still running" /app/bot.log; then
              LAST_HEARTBEAT=$(grep "Heartbeat: Bot is still running" /app/bot.log | tail -1)
              echo "‚úÖ Found heartbeat: $LAST_HEARTBEAT"
            else
              echo "‚ö†Ô∏è No recent heartbeat messages found"
            fi
            
            # Check for errors in recent logs
            if tail -20 /app/bot.log | grep -i "error\|exception\|failed" > /dev/null; then
              echo "‚ö†Ô∏è Recent errors found in logs:"
              tail -20 /app/bot.log | grep -i "error\|exception\|failed"
            else
              echo "‚úÖ No recent errors in bot logs"
            fi
          else
            echo "‚ö†Ô∏è No bot log file found"
          fi
          
          # Primary health check: Discord API response
          if check_discord_health; then
            echo ""
            echo "üéâ === HEALTH CHECK SUMMARY ==="
            echo "‚úÖ PRIMARY: Discord API health check PASSED"
            echo "‚ÑπÔ∏è  Process status: $PROCESS_STATUS"
            echo "‚úÖ Bot is confirmed working and responding to Discord"
            echo "‚úÖ Deployment is SUCCESSFUL"
            exit 0
          else
            echo ""
            echo "‚ùå === HEALTH CHECK SUMMARY ==="
            echo "‚ùå PRIMARY: Discord API health check FAILED"
            echo "‚ÑπÔ∏è  Process status: $PROCESS_STATUS"
            echo "‚ùå Bot may not be responding to Discord properly"
            echo "Check logs above for details"
            exit 1
          fi
        shell: bash
      - name: Capture Deployment Logs
        if: always()
        run: |
          echo "=== Final deployment status ==="
          
          # Use gcloud SSH to check deployment status
          gcloud compute ssh arccorp-compute --zone=us-central1-a --project=rl-prod-471116 --command='
            # Check if this is a first deployment
            if [ ! -d /app ]; then
              echo "‚ÑπÔ∏è  First deployment in progress - /app directory does not exist yet"
              echo "This is normal during initial setup"
              echo "=== System resource check ==="
              free -h || echo "Could not check memory"
              echo "=== Deployment log capture completed ==="
              exit 0
            fi
            
            # Show bot status
            if [ -f /app/bot.pid ]; then
              if kill -0 $(cat /app/bot.pid) 2>/dev/null; then
                echo "‚úÖ Bot is running (PID: $(cat /app/bot.pid))"
              else
                echo "‚ùå Bot process exists but is not running"
              fi
            else
              echo "‚ùå No bot PID file found"
            fi
            
            # Show recent logs
            if [ -f /app/bot.log ]; then
              echo "=== Last 20 lines of bot log ==="
              tail -20 /app/bot.log
            else
              echo "‚ùå No bot log file found"
            fi
            
            # Check system resources
            echo "=== System resource check ==="
            if [ -d /app ]; then
              df -h /app || echo "Could not check disk space for /app"
            else
              df -h / || echo "Could not check disk space"
            fi
            free -h || echo "Could not check memory"
            
            echo "=== Deployment log capture completed ==="
          ' || echo "Could not capture deployment logs - VM may be unreachable"
        shell: bash
    env:
      DATABASE_URL: ${{ secrets.DATABASE_URL }}

  post-deployment:
    if: always()
    needs: deploy-arccorp-compute
    runs-on: ubuntu-latest
    steps:
      - name: Add Ready to Merge Label on Success
        if: needs.deploy-arccorp-compute.result == 'success'
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            try {
              // Remove deploy label
              try {
                await github.rest.issues.removeLabel({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: context.payload.pull_request.number,
                  name: 'deploy'
                });
                console.log('Deploy label removed successfully');
              } catch (error) {
                if (error.status === 404) {
                  console.log('Deploy label not found, nothing to remove');
                } else {
                  console.error('Failed to remove deploy label:', error.message);
                }
              }
              
              // Add ready to merge label
              await github.rest.issues.addLabels({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.payload.pull_request.number,
                labels: ['ready to merge']
              });
              console.log('Ready to Merge label added successfully');
              
              // Add success comment
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.payload.pull_request.number,
                body: '‚úÖ **Deployment Successful**\\n\\nThe bot has been successfully deployed and is responding to Discord. The deployment is ready to be merged.\\n\\nAdd the `merge` label to trigger the merge workflow.'
              });
            } catch (error) {
              console.error('Failed to update labels after successful deployment:', error.message);
            }
            
      - name: Add Bug Label and Reset on Failure
        if: needs.deploy-arccorp-compute.result == 'failure'
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            try {
              // Remove workflow labels
              const labelsToRemove = ['tests good', 'deploy', 'ready to merge'];
              for (const label of labelsToRemove) {
                try {
                  await github.rest.issues.removeLabel({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    issue_number: context.payload.pull_request.number,
                    name: label
                  });
                  console.log(`${label} label removed successfully`);
                } catch (error) {
                  if (error.status === 404) {
                    console.log(`${label} label not found, nothing to remove`);
                  } else {
                    console.error(`Failed to remove ${label} label:`, error.message);
                  }
                }
              }
              
              // Add bug label
              await github.rest.issues.addLabels({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.payload.pull_request.number,
                labels: ['bug']
              });
              console.log('Bug label added successfully');
              
              // Add failure comment
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.payload.pull_request.number,
                body: '‚ùå **Deployment Failed**\\n\\nThe bot deployment to the compute instance failed. Check the deployment logs above for detailed error information including:\\n- Python dependency installation errors\\n- Database connection issues\\n- Bot startup failures\\n- System resource problems\\n\\nPlease review the logs and fix any issues. Once fixed, tests will need to pass again before re-attempting deployment.'
              });
              
            } catch (error) {
              console.error('Failed to update labels after deployment failure:', error.message);
            }
